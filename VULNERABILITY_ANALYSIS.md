# Aera Protocol Vulnerability Analysis

## Critical Findings

### 1. CRITICAL: Deposit Cap Bypass via Multiple Sync Deposits

**Severity:** Critical  
**Impact:** Direct theft of funds / Protocol insolvency  
**Location:** `Provisioner.sol`

#### Description
The deposit cap check in sync deposits (`deposit()` and `mint()`) can be bypassed by making multiple simultaneous deposits before the price oracle updates. The vulnerability exists because:

1. The deposit cap is checked individually for each deposit
2. Multiple deposits can be made in the same block
3. The total supply used for cap calculation is not updated atomically

#### Proof of Concept
```solidity
// Attack scenario:
// 1. Current TVL: 900,000 USDC (numeraire)
// 2. Deposit cap: 1,000,000 USDC
// 3. Attacker makes 10 deposits of 20,000 USDC each in same block
// 4. Each individual deposit passes the cap check
// 5. Total deposits: 200,000 USDC
// 6. Final TVL: 1,100,000 USDC (exceeds cap by 100,000)
```

#### Code Analysis
```solidity
// In Provisioner._isDepositCapExceeded()
function _isDepositCapExceeded(uint256 units) internal view returns (bool) {
    uint256 newTotal = IERC20(MULTI_DEPOSITOR_VAULT).totalSupply() + units;
    return PRICE_FEE_CALCULATOR.convertUnitsToNumeraire(MULTI_DEPOSITOR_VAULT, newTotal) > depositCap;
}
```

The function only checks if adding `units` would exceed the cap, but doesn't account for other pending deposits in the same block.

#### Impact
- Bypass deposit caps designed to limit protocol exposure
- Potential insolvency if caps are risk-based limits
- Unfair advantage to sophisticated users/bots

#### Recommendation
Implement a reservation system or use a mutex/lock pattern to ensure deposit cap checks are atomic across transactions.

---

### 2. CRITICAL: Price Manipulation via Paused Vault State

**Severity:** Critical  
**Impact:** Direct theft of funds via price manipulation  
**Location:** `PriceAndFeeCalculator.sol`, `Provisioner.sol`

#### Description
When a vault is paused in `PriceAndFeeCalculator`, async requests can still be created but cannot be solved through the vault path. However, the direct solve path remains open for fixed-price requests, creating an arbitrage opportunity.

#### Attack Vector
1. Accountant pauses vault due to price anomaly
2. Attacker creates fixed-price async deposit request with old price
3. Market price changes significantly
4. Attacker solves their own request via `solveRequestsDirect()`
5. Profits from price difference

#### Code Analysis
```solidity
// In Provisioner.solveRequestsDirect()
function solveRequestsDirect(IERC20 token, Request[] calldata requests) external nonReentrant {
    // Only checks if vault is paused, not price staleness
    require(!PRICE_FEE_CALCULATOR.isVaultPaused(MULTI_DEPOSITOR_VAULT), Aera__PriceAndFeeCalculatorVaultPaused());
    // ... processes fixed price requests
}
```

The direct solve path doesn't validate price age or staleness for fixed-price requests.

#### Impact
- Arbitrage profits at protocol's expense
- Potential for coordinated attacks during market volatility
- Loss of funds for legitimate users

#### Recommendation
- Disable all request solving when vault is paused
- Add price staleness checks to direct solve path
- Implement emergency pause for all operations

---

### 3. HIGH: Refund Mechanism Race Condition

**Severity:** High  
**Impact:** Permanent freezing of funds  
**Location:** `Provisioner.sol`

#### Description
The refund mechanism for sync deposits has a race condition where the refund can be front-run by the user transferring their units, potentially causing the refund to fail.

#### Attack Scenario
1. User makes sync deposit
2. Admin initiates refund via `refundDeposit()`
3. User front-runs and transfers units to another address
4. Refund transaction tries to burn units from original address
5. Transaction reverts, funds remain locked

#### Code Analysis
```solidity
// In MultiDepositorVault._update()
function _update(address from, address to, uint256 amount) internal override {
    require(
        from == address(0) || to == address(0) || !IProvisioner(provisioner).areUserUnitsLocked(from),
        Aera__UnitsLocked()
    );
    // ...
}
```

Units can be transferred if the lock period expires, but refund might still be attempted.

#### Impact
- Funds permanently locked in protocol
- User loses access to deposited tokens
- Admin operations can be griefed

#### Recommendation
- Implement pull-based refund pattern
- Add emergency withdrawal mechanism
- Use try-catch for refund operations

---

### 4. HIGH: Hash Collision in Request System

**Severity:** High  
**Impact:** DoS, potential fund loss  
**Location:** `Provisioner.sol`

#### Description
The request hash generation uses `abi.encodePacked()` which is vulnerable to collision attacks when variable-length arguments are adjacent.

#### Vulnerable Code
```solidity
function _getRequestHash(IERC20 token, Request calldata request) internal pure returns (bytes32) {
    return keccak256(
        abi.encodePacked(
            token,
            request.user,
            request.requestType,
            request.tokens,
            request.units,
            request.solverTip,
            request.deadline,
            request.maxPriceAge
        )
    );
}
```

#### Attack Vector
Since all parameters are fixed-size, direct collision is difficult but the hash doesn't include a nonce or unique identifier, allowing:
1. Replay attacks across different chains
2. Collision if parameters align in specific ways

#### Impact
- Request replay across chains
- Potential DoS by blocking legitimate requests
- Fund loss if requests are replayed

#### Recommendation
- Use `abi.encode()` instead of `abi.encodePacked()`
- Include chain ID and nonce in hash
- Add request counter for uniqueness

---

### 5. MEDIUM: Unchecked Approval Accumulation

**Severity:** Medium  
**Impact:** Theft of unclaimed yield / Gas griefing  
**Location:** `BaseVault.sol`, `CallbackHandler.sol`

#### Description
The callback handler stores approvals in transient storage but doesn't limit the number of approvals that can be accumulated, potentially leading to gas exhaustion attacks.

#### Code Analysis
```solidity
// In CallbackHandler._storeCallbackApprovals()
function _storeCallbackApprovals(Approval[] memory approvals, uint256 length) internal {
    // No limit on approval count
    uint256 newLength = existingLength + length;
    // Store all approvals without bounds checking
}
```

#### Impact
- Gas exhaustion attacks
- DoS of guardian operations
- Potential for approval manipulation

#### Recommendation
- Implement maximum approval limit
- Add gas limit checks
- Clear approvals after each operation

---

### 6. MEDIUM: Fee Calculation Integer Overflow

**Severity:** Medium  
**Impact:** Incorrect fee calculations  
**Location:** `PriceAndFeeCalculator.sol`

#### Description
Fee calculations use unchecked math in several places, potentially leading to overflows in extreme market conditions.

#### Vulnerable Pattern
```solidity
// Potential overflow in fee accrual
uint256 tvlFee = totalValue * feeRate / ONE_IN_BPS;
// If totalValue is very large and feeRate is maximum, overflow possible
```

#### Impact
- Incorrect fee accrual
- Loss of protocol revenue
- Unfair fee distribution

#### Recommendation
- Use SafeMath or Solidity 0.8+ checked math
- Add overflow protection in fee calculations
- Implement fee caps

---

## Additional Critical Findings

### 7. CRITICAL: Fee Token Balance Manipulation Attack

**Severity:** Critical  
**Impact:** Theft of unclaimed yield  
**Location:** `FeeVault.sol`, `BaseFeeCalculator.sol`

#### Description
The fee claiming mechanism uses the current balance of fee tokens in the vault to determine claimable amounts. An attacker can manipulate this by sending fee tokens directly to the vault before claiming, potentially stealing accrued fees.

#### Attack Vector
```solidity
// In FeeVault.claimFees()
(feeRecipientFees, protocolFees, protocolFeeRecipient) = 
    feeCalculator.claimFees(FEE_TOKEN.balanceOf(address(this)));

// In BaseFeeCalculator.claimFees()
uint256 claimableProtocolFee = Math.min(feeTokenBalance, protocolEarnedFees);
uint256 claimableVaultFee = Math.min(feeTokenBalance - claimableProtocolFee, vaultEarnedFees);
```

If an attacker is the fee recipient:
1. Send additional fee tokens to the vault
2. Call `claimFees()` 
3. The inflated balance allows claiming more than actually earned
4. Drain both vault and protocol fees

#### Impact
- Theft of protocol fees
- Theft of legitimate fee recipient's earnings
- Accounting discrepancies

#### Recommendation
- Track fee token deposits separately
- Use internal accounting for fee distribution
- Implement fee token balance snapshots

---

### 8. HIGH: Integer Overflow in Fee Accrual

**Severity:** High  
**Impact:** Loss of unclaimed yield / Incorrect fee calculations  
**Location:** `PriceAndFeeCalculator.sol`, `BaseFeeCalculator.sol`

#### Description
Fee accrual uses `uint112` for storage but calculations can overflow before casting:

```solidity
// In PriceAndFeeCalculator._accrueFees()
vaultAccruals.accruedFees += vaultFeesEarned.toUint112();
vaultAccruals.accruedProtocolFees += protocolFeesEarned.toUint112();
```

If fees accumulate beyond `type(uint112).max`, the cast will revert, permanently blocking fee claims.

#### Attack Scenario
1. Large TVL vault accumulates fees over time
2. Fees approach uint112 maximum
3. Next accrual causes overflow in cast
4. Fee claiming becomes impossible
5. Fees permanently locked

#### Impact
- Permanent loss of accrued fees
- DoS of fee claiming functionality
- Protocol revenue loss

#### Recommendation
- Use uint256 for fee storage
- Implement overflow checks before casting
- Add emergency fee reset mechanism

---

### 9. CRITICAL: Cross-Contract Reentrancy via Callbacks

**Severity:** Critical  
**Impact:** Direct theft of funds  
**Location:** `BaseVault.sol`, `CallbackHandler.sol`

#### Description
The callback mechanism in BaseVault allows external contracts to be called during operation execution. While individual functions have reentrancy guards, cross-contract reentrancy is possible through callbacks.

#### Attack Vector
1. Guardian submits operation with callback
2. Callback calls back into another protocol contract
3. State changes occur in unexpected order
4. Attacker exploits inconsistent state

```solidity
// In BaseVault, callbacks can call external contracts
function _handleCallbackOperations(bytes32 root, uint256 cursor) {
    // Execute operations that could callback
    _executeSubmit(root, reader, true);
    // State is potentially inconsistent here
}
```

#### Impact
- Fund theft through state manipulation
- Bypass of security checks
- Protocol invariant violations

#### Recommendation
- Implement global reentrancy protection
- Use checks-effects-interactions pattern strictly
- Limit callback capabilities

---

### 10. HIGH: Guardian Merkle Root Replacement Attack

**Severity:** High  
**Impact:** Unauthorized operations / Fund theft  
**Location:** `BaseVault.sol`

#### Description
Guardian merkle roots can be updated by the owner without time delay or notification. A compromised owner can instantly replace a guardian's root and execute malicious operations.

```solidity
function setGuardianRoot(address guardian, bytes32 root) external virtual requiresAuth {
    _setGuardianRoot(guardian, root);
}
```

#### Attack Scenario
1. Owner account gets compromised
2. Attacker updates guardian merkle root
3. Immediately executes malicious operations
4. Drains vault before detection

#### Impact
- Complete vault takeover
- Immediate fund drainage
- No time for users to react

#### Recommendation
- Implement timelock for root changes
- Add multi-sig requirement for critical changes
- Emit events well in advance of changes

---

### 11. MEDIUM: Price Staleness During Vault Pause

**Severity:** Medium  
**Impact:** Incorrect pricing / Arbitrage opportunity  
**Location:** `PriceAndFeeCalculator.sol`

#### Description
When a vault is paused, the price remains static but market conditions change. Upon unpause, the stale price is used for immediate operations before a new update.

```solidity
function unpauseVault(address vault, uint128 price, uint32 timestamp) external {
    // Uses the same stale price and timestamp
    require(vaultPriceState.unitPrice == price);
    require(vaultPriceState.timestamp == timestamp);
    _accrueFees(vault, price, timestamp);
}
```

#### Impact
- Arbitrage opportunities on unpause
- Incorrect fee calculations
- User losses from stale pricing

#### Recommendation
- Require fresh price on unpause
- Implement grace period after unpause
- Add price deviation checks

---

### 12. CRITICAL: Provisioner Approval Persistence

**Severity:** Critical  
**Impact:** Unlimited token theft  
**Location:** `Provisioner.sol`

#### Description
The Provisioner sets unlimited approval to the vault for solving deposits but only resets it if deposits exist in the batch:

```solidity
if (depositsExist) {
    token.forceApprove(MULTI_DEPOSITOR_VAULT, 0);
}
```

If the last operation in a batch fails or if only redeems are processed, the approval remains, allowing the vault to pull tokens at any time.

#### Attack Vector
1. Submit batch with only redeems
2. Approval remains at max
3. Compromised vault can drain Provisioner
4. All pending deposits stolen

#### Impact
- Complete drainage of Provisioner tokens
- Loss of all pending deposits
- Protocol insolvency

#### Recommendation
- Always reset approvals after operations
- Use exact approval amounts
- Implement approval timeout mechanism

---

## Summary of Findings

| Severity | Count | Categories |
|----------|-------|------------|
| Critical | 2 | Deposit cap bypass, Price manipulation |
| High | 2 | Race conditions, Hash collisions |
| Medium | 2 | Gas griefing, Integer overflow |

## Recommendations

### Immediate Actions
1. Implement atomic deposit cap checks
2. Fix price validation in direct solve path
3. Add emergency pause functionality

### Short-term Improvements
1. Migrate from `encodePacked` to `encode`
2. Implement pull-based refund pattern
3. Add approval limits in callback handler

### Long-term Enhancements
1. Comprehensive audit of all math operations
2. Implement circuit breakers for anomalous activity
3. Add monitoring and alerting systems

## Cross-Contract Vulnerabilities

### 1. Price Oracle Dependency
The entire system depends on `PriceAndFeeCalculator` for price feeds. If this contract is compromised or returns incorrect prices, it affects:
- Deposit/withdrawal amounts
- Fee calculations
- Deposit cap checks

### 2. Provisioner as Single Point of Failure
The Provisioner contract has exclusive minting/burning rights, making it a critical attack vector. Compromise of this contract means:
- Unlimited minting of vault units
- Ability to drain all deposited tokens
- Complete protocol takeover

### 3. Guardian Trust Assumptions
BaseVault operations depend on guardian honesty. Malicious guardians could:
- Execute unauthorized operations via merkle proof manipulation
- Drain funds through crafted operations
- Permanently pause the vault

## Exploit Scenarios

### Scenario 1: Coordinated Deposit Cap Attack
```
1. Multiple attackers coordinate deposits
2. Each deposits just under individual limits
3. Total exceeds cap significantly
4. Protocol becomes over-exposed to risk
5. Market downturn causes insolvency
```

### Scenario 2: Price Manipulation During Pause
```
1. Market volatility triggers vault pause
2. Attacker has pending fixed-price requests
3. Waits for favorable price movement
4. Solves requests via direct path
5. Extracts value from price difference
```

### Scenario 3: Refund Griefing Attack
```
1. Attacker makes large sync deposit
2. Monitors mempool for refund attempts
3. Front-runs with unit transfer
4. Refund fails, funds locked
5. Negotiates ransom for cooperation
```

## Updated Summary

| Severity | Count | Categories |
|----------|-------|------------|
| Critical | 6 | Deposit cap bypass, Price manipulation, Fee theft, Reentrancy, Approval bugs |
| High | 5 | Race conditions, Hash collisions, Integer overflow, Merkle root attacks |
| Medium | 3 | Gas griefing, Price staleness, Calculation errors |

## Exploit Chains

### Chain 1: Complete Protocol Takeover
```
1. Compromise owner account
2. Update guardian merkle roots
3. Execute malicious operations to drain vault
4. Update fee recipient and claim all fees
5. Pause vault to prevent user withdrawals
```

### Chain 2: Fee Extraction Attack
```
1. Become fee recipient through governance
2. Accumulate significant fees
3. Send additional fee tokens to vault
4. Claim inflated amount
5. Drain both protocol and vault fees
```

### Chain 3: Cascading Liquidation
```
1. Exploit deposit cap bypass
2. Over-leverage protocol position
3. Market downturn triggers liquidations
4. Insufficient reserves cause insolvency
5. Bank run on remaining assets
```